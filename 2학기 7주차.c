// 교환할 때는 주소를 넘겨주는게 중요하다!!
// main의 100번지는 함수의 100번지와 같다 !@
//
#if 0 
unsigned char
*p1 ,*p2,
a[100] = {0} , b[2][3][5],
c =7 , d=128;
int i = 1029, * ip;

p1 = &i;
ip = &c;
*p1 = 257;
*ip = 0x06070809;
#endif
// i = 1025 , *p1 =1, c = 9, d=128 *ip = 0x06070809
// p1이 가리키는 곳에는 05가 있다
// ip = &c에서 ip의 값은 c의 주소의 첫 바이트는 알고 그 이후는 알지 못한다 - 쓰레기값
// *p1 = 257 = 256+1 앞에 256은 버리고 1만 남음-- 1바이트 최대 255이기 때문에.
// 
// ip = &a[3];
// *ip = 0x06070809;
// a[3] = 09 , a[4]= 08, ...
// a[6] = 4를 넣은 후에
// *ip의 값을 보면 04070809
// ip에 -4를 넣으면 05080704로 저장되고 값은 04070805이다
// 
// 
#if 0 
char c = 5, d = 6, e = 0xEC;
char ca[5] = { 'p','q','r','s','t' }, da[5];
int i = 50, j = 50, k = 0xF8;
int ia[5] = { 16,32,64,1,4 };
char* cp, * dp;
int* ip, * jp;
#endif
// char[5]에는 NULL값이 없다. 문제점이 있겠는가? 이유는? 틀리지는 않으나 NULL이 없으니까 string과 관련된 문자는 사용할 수 없다.
// ca[4] = 'X'는 가능한가? ㅇㅇ
// printf("%s",ca); 문법적으로는 맞으나 NULL을 찾을때까지 돌아가야해서 값이 안 나올수도 있음
// 
// cp = (char*) ia; 맞겠는가? 서로 주소이기 때문에 맞다. ia는 int의 배열이고 cp는 char형 포인터이기 때문에
// cp의 값은 얼마인가? 이유는?  16
// *cp의 값은 16
// *(cp + 1) = 0
// *(cp + 2) = 0
// *(cp + 3) = 0
// *(cp + 4) = 32 
// cp[4] = 32
//
// 
// char c[100]; int i[100]에 대해서,
// test(c,i)를 호출할 때
// test(char*pc, int *pi)로 받아야한다.
// 
// 로컬변수참조 x!! -- 함수의 주소를 main의 주소에 가져오지 말자
//





