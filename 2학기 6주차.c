//주소의 값이 넘어가는지 복사본이 넘어가는지 그냥 값이 넘어가는지 잘 확인해야됨.
// 포인터 변수는 메모리의 주소를 저장하는데 쓰이는 변수이다.
// 주소로부터 1byte,2byte,4byte 등이 하나의 데이터일 수 있다. 그것을 구분해 주는 것이 포인터 변수의 형(type, 즉 char, short, int 등)이다.
// char, short, int는 첫 주소는 같지만 끝 주소가 어디인지 각각 다르다.
// 모든 데이터는 바이트 단위로 주소를 가지고 있다. 따라서 저장되는 주소는 바이트의 주소이다
// 
//포인터 변수는 왜 필요한가?
// 프로그램에는 데이터가 반드시 필요하다
// 그 데이터는 하나의 정해진 값만 저장하는 것이 아니라, 필요에 의해 그 값을 변경하여 저장한다.
// 메모리를 직접 가리키고, 처리할 수 있는 c언어
// 데이터들을 필요에 따라, 가리키고, 변경시키고, 하는 등의 처리가 필요하다.
// 
//포인터 변수의 선언
// 일반 변수의 선언과 같으나 변수 앞에 *를 붙인다. *는 1개 이상 붙일 수 있다.
// int*p;  --  (p ,*p, &p)를 알 수 있다. p의 값,p의 포인터 , p의 값이 있는 주소 p+1 = 1004
// char*p;                                                                      p+1 = 1001
// 정수 변수의 주소를 저장하는 정수 포인터 변수(int*)
// 실수 변수의 주소를 저장하는 실수 포인터 변수(float*)
// 
//포인터 변수는 각 데이터 타입별로 있다.
//더 후반부에는 struct와 같이 사용자가 지정한 임의의 크기를 가지는 메모리도 포인터로 가리키며 연산할 수 있다.
// + -                     
// p = 0; p에 0번저를 넣는다.
// p=NULL; 여기서 NULL은 0번지와 같다
// p = &i; p에 i의 주속번지값을 넣는다ㅑ
// p = (int*)
// 
// &연산자는 변수의 주소를 돌려주는 연산자이다.
// &p : 변수 p의 주소이다.
// scanf("%d,&p)
// 
// float i <- 이런 식으로 사용된다
#if 0
#include<stdio.h>
#define STUDENT 6
int main() {
	int sn = STUDENT;
	int total_score = 39;
	float avg_score;
	avg_score = (float)total_score / sn;

}
#endif
//배열과 포인터의 관계 
// int a[100]
// 우리는 a가 첫번째 "큰 덩어리"의 주소라고 기억하자
// a[0]~a[99]까지의 100개만 유의미하게 관리하며, a[100]의 위치는 접근할수는 있지만 값에 대해서는 책임지지 않는다.
// 
// int[100]; int*iptr;
// iprt 은 int pointer type 변수이다 
// iptr = a; [a의 값 1000번째가 저장된다.)
// 
//iptr로 할 수 있는 일 
// *iptr은 a[0]이다.
// 정화하게 a[0]은 *(iptr +  0)을 의미한다.
// []는*와(+) 와 완전히 동일한 의미이다.
// 여기서 +는 더하기가 아니라 "다음"의 의미이다.
// 컴퓨터는 "다음"이 없으므로, 각 크기를 더해서 더할 숫자를 미리 정한다.
// iptr +1의 값은?
// a[0]의 다음 원소인 a[1]의 주소이다. 
// 이 "다음"을 명확하게 알기 위해 가리키는 곳의 크기가 중요한 것이다.
// iptr은 int pointer이기 때문에 iptr + 1 은 1001이 아니라 정수의 크기에 맞춰 1004이다.
// 따라서*(iptr + 1)은 a[1]이다.
// 
// 연산자이기 때문에 a[3] = *(a+3) = *(3+a) = 3[a]이 맞다
// 
// Big Endian
// 0x12345678 데이터를 번지 순서대로 저장함
// 0x10 0x11 0x12 0x13(번지)
// 0x12 0x34 0x56 0x78(데이터)
// 
// Little Endian
// 0x10 0x11 0x12 0x13(번지)
// 0x78 0x65 0x43 0x21(데이터)
//
